# 进程与线程

### 基本概念

**官方概念：**

- 进程是 CPU **资源分配**的最小单位
- 线程是 CPU **调度**的最小单位

在真正理解线程和进程概念之前要先回顾一下之前嵌入式里面学的虚拟地址概念。计算机是如何用较小的硬件内存来存储很大的内存，就是通过地址映射+硬盘内存映射出远大于实际大小的内存空间。要通过虚拟地址拿到实际地址上的内容，就要通过查表，通过一级页表+二级页表+大小页表的方式拼接得到实际地址，所以这种映射方式是允许多个虚拟地址指向同一个实际地址的。

而进程拥有一块独立的虚拟地址空间，线程则是运行在其中的多个执行流，它们共享进程中的全部内存资源。



### 线程与进程特点：

1. 一个线程阻塞会影响其他线程的运行，但各个进程之间互不干扰。
2. 线程之间共享进程的资源。
3. 当一个进程被关闭时会回收进程中的资源，所以即使进程中的线程由于不正确调用导致内存泄漏也会在进程关闭时被全部回收。

[^回收]: 这里又涉及JS的垃圾回收机制，为了不让篇幅变得冗长会在JS里另开一篇加以说明。



**易知浏览器是多线程的**

最新的Chrome浏览器包含：

- 一个浏览器主进程：负责界面显示、页面交互、子进程管理以及存储等功能
- 一个GPU进程：起初GPU是为了3D CSS产生的，随后网页、Chrome的UI界面都选择用GPU渲染，于是也就引入了GPU进程。
- 一个网络进程：主要用于网页资源加载。
- 若干个渲染进程：将CSS、HTML和JavaScript渲染到页面中，排版引擎和JavaScript的V8引擎都在这个进程内，浏览器会给每个标签页创建一个渲染进程，每个渲染进程通常都在沙箱模式下运行。
- 若干个插件进程

多进程模式让浏览器更加**流畅、稳定、安全**，但也增添了许多问题：

1. 更多的资源占用
2. 更复杂的体系架构



## 常见面试题

### 浏览器渲染进程有哪些线程：

1. **GUI渲染线程**

复杂渲染页面，解析HTML、CSS，构建DOM树、CSSOM树、构建Render树并绘制页面；当页面需要重绘或回流时都用到这个线程。

要注意的是GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，被保存在队列中当JS引擎空闲时立即执行。

2. **JS引擎线程**

负责执行JavaScript脚本程序，解析JavaScript脚本、执行代码；JS引擎一直等待着任务队列中任务的到来，众所周知JavaScript是单线程的，所以无论什么情况下一个标签页内都只会有一个JS引擎线程。

3. **事件触发线程**

事件触发线程属于浏览器而不是JS引擎，负责控制JS的事件循环，将事件符合触发条件时事件触发线程会将其添加到任务队列的队尾等待JS引擎的处理。

4. **定时器触发线程**

用于计时并触发计时器，计时完毕后交给事件触发线程将任务添加到任务队列中。

5. **异步HTTP请求线程**

负责发起网络请求，并在请求完成后把回调函数加到任务队列中等待JS引擎执行。



由此不得不引出一个特别常考的面试题：

### **浏览器从输入URL到渲染完毕经过了那些过程？**

1. **解析URL**

完整的URL包括协议、域名、端口号、路径和查询参数。输入URL后浏览器会首先解析识别出其中的协议、域名、端口号、路径、查询参数和片段标识符。还会检查是否由<u>HSTS</u>记录，如果有会把协议转换成`https://`。

[^HSTS]: 是一种由服务器通过响应头`Strict-Transport-Security`告知浏览器的安全策略，用来强制客户端再之后的访问中只能使用HTTPS。

------

2. **DNS解析**

将域名转换成IP地址，域名只是方便用户读写，浏览器则需要目标服务器的IP地址才能建立连接。

[^DNS]: 全名 Domain Name System，即域名系统，是一种用于将域名解析为IP地址的系统。

​	**DNS域名解析过程：**

该过程包含递归查询和迭代查询。由浏览器像本地DNS服务器递归查询，而本地DNS服务器对于根域名服务器、顶级域名服务器、权威域名服务器则是迭代查询。

- 首先会在浏览器缓存中查找是否有该域名对应的IP地址，如果有直接返回。

- 如果没有则像本地DNS服务器发送查询请求，如果有则直接返回。

  <!--这是一个分界线，上面是递归查询下面是迭代查询-->

- 如果没有则向根域名服务器发送查询请求，根域名服务器返回一个所查域名的顶级域名服务器地址。

- 再去查顶级域名服务器，会返回一个权威域名服务器地址。

- 再去查权威域名服务器，最终返回域名对应的IP地址并将结果返回给本地DNS服务器。

- 本地DNS服务器会将结果保存在缓存中并返回给浏览器。

- 浏览器也会将结果保存在缓存中并使用IP地址访问目标网站。

------

3. **建立TCP连接**

这又是面试高频题，TCP连接的三次握手四次挥手。

​	**三次握手：**

①第一次握手：客户端向服务端发送SYN包，并且客户端进入SYN_SENT状态。

②第二次握手：服务端收到客户端发来的包后状态变为SYN_RECV，并发送[SYN/ACK]包。

③第三次握手：客户端收到服务端返回的包时就知道服务端能够收到请求并发出响应，客户端进入ESTABLISHED状态（连接成功），并返回ACK包给服务端，服务端也知道客户端能够收到响应，变为ESTABLISHED状态，成功建立连接，握手结束。

刚开始客户端处于CLOSED状态，服务端处于LISTEN状态。


**握手的一些细节：**

①第一次握手客户端发的标识位SYN=1，以及序列号seq=x（随机数字）

②第二次握手服务端收到客户端发的标识位和序列号后会返回标识位SYN=1，ACK=1，序列号seq=y（随机数字），以及确认码ack number=x+1（第一次握手客户端发来的序列号+1）。

③第三次握手客户端要确认标识符和序列号是否匹配，若正确则建立连接。



了解这个细节后即可解释下一个高频面试题：

**为什么是三次握手而不是两次或四次：**

三次握手正好让服务端确认客户端能够正确发送请求，让客户端确认服务端能够收到正确序列号的请求并返回对应的响应。如果只有两次服务端无法确定客户端收到的响应是否正确，而四次则多余了。



在建立了TCP连接后，如果是HTTPS协议，还需要进行TLS/SSL握手。

------

4. **浏览器向服务器发送HTTP请求**

建立连接后浏览器会向服务器发送HTTP请求获得资源，服务器根据请求生成最终HTTP响应并将响应报文发送回浏览器。



这里面又涉及几个计算机网络常考点：

**HTTP请求报文由什么组成？**

请求行、请求头、空行和请求体。

- 请求行：包含请求方法、URI（请求的资源路径）、HTTP协议版本。
- 请求头：一些额外的附加信息，例如浏览器类型、字符编码、认证信息等等。以键值对的方式存在。
- 请求体：存放请求参数，即浏览器向服务器传输数据的实体部分。

为什么要有空行？

空行相当于请求头和请求体的分隔符，HTTP协议没有规定请求头的键值对有多少个，用空行表示请求头已结束。



**HTTP响应报文由什么组成？**

与请求报文同理，响应行、响应头、空行、响应体。

- 响应行：HTTP协议版本、状态码和状态码的原因短语。例如：HTTP/1.1 200 OK。
- 响应头：与请求头类似，以键值对的形式描述响应的一些元信息。
- 响应体：服务器响应的数据。

------

5. **浏览器对响应进行处理**

拿到响应报文后浏览器会对其进行处理，根据不同状态码和响应头信息做出反应。

- 如果状态码是3xx，浏览器会从响应头中的`Location`字段拿到新的URL并重新开始解析（从头开始）。
- 浏览器检查响应头中的缓存字段（如`Cache-Control`、`Expires`、`ETag`、`Last-Modifired`），如果资源可被缓存则保存到本地，如果是304说明可以直接使用本地缓存。

[^304]: 304 Not Modified 是协商缓存的结果，表示资源自上次访问以来没有变化这次可以直接使用本地缓存，服务器发送的响应体为空。

- 若状态码为200且内容是HTML则浏览器开始进入渲染阶段。



由此又可以引出高频面试题——常见的状态码，在此不作赘述，计网部分会总结。

------

6. **页面渲染**

渲染阶段大致分为以下几步：

- 解析HTML构建DOM树、解析CSS构建CSSOM树
- 将DOM树和CSSOM树合并为Render树
- 根据Render树计算布局
- 将生成的布局信息交给浏览器的绘图引擎由GPU加速绘制
- 如果页面发生改变会引起回流和重绘



**（1）解析HTML构建DOM树**

解析过程中遇到CSS解析CSS，遇到JS执行JS，由于渲染过程中遇到JS会暂停文档解析转而将控制权交给JS引擎线程，为了提高解析速度于是引入了预解析。预解析会在执行脚本时让另一个线程解析剩下的文档并加载后面需要通过网络加载的资源。

由此可以解释为什么CSS解析不会阻塞HTML解析而JS会：

CSS解析是在预解析线程中进行的，而如果主线程解析到script位置会停止解析HTML转而等待JS执行完毕后再继续解析。

**（2）解析CSS构建CSSOM树**

类似于解析HTML的过程，但CSS解析是不会阻塞HTML的。

**（3）合成Render树（样式计算）**

渲染树只会包括要显示的节点及其样式信息，如果某个节点是`display:none`则不会加入Render树。在这一过程中会计算出每个节点的最终样式，很多预设值都会变成绝对值，像`red`会变成`rgb(255,0,0)`，相对单位会变成绝对单位。

这其中有一个可能混淆的概念是`diff`算法，合成Render树的过程是完全不涉及diff算法的。合成Render树由浏览器完成，而diff算法是框架用于比较新旧虚拟DOM的算法，可以说框架利用diff算法得到最终要生成的DOM树然后交给浏览器进行合成Render树。

**（4）布局**

布局完成后会生成布局树。布局树是Render树经过计算后明确每一个元素节点的位置后生成的树，比Render树更加清晰知道页面要如何渲染布局。

至此出现了四棵树：DOM树、CSSOM树、Render树、Layout树。DOM树和CSSOM树是同级的，而二者到Render树再到Layout树则是逐层优化生成的。

**（5）分层**

浏览器会用一种复杂的机制将布局树分层，后续层内元素发生改变可以减少对其他层的影响。

**（6）绘制**



### <u>进程</u>间的通信方式：

1. **管道通信**

管道通信是最基本的一种进程间通信，就是操作系统在内核中开辟出一块缓冲区，进场a将需要交互的数据拷贝到缓冲区，进程2就可以访问了。



**管道特点：**

- 只能单向通信
- 只能血缘关系的进程进行通信（与管道通信的FD表有关）
- 依赖于文件系统
- 生命周期随进程
- 面向字节流服务
- 管道内部提供了同步机制



2. **消息队列通信**

顾名思义就是一个可以存放消息的队列，用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送数据块的方法。



3. **信号量通信**

信号量本质就是一个计数器，用来实现进程之间的互斥与同步。



4. **信号通信**



5. **共享内存通信**



6. **套接字通信**





### 浏览器是多进程但JS是单线程，为什么？怎么实现多线程？

JS起初设计是为了实现页面交互，采用单线程更加简单，开发门槛也比较低，并且在实现页面交互时如果是多线程就会出现不同线程同时操作DOM的情况，当然可以引入锁来解决这个问题，但就会让开发更加复杂。

虽然JS是单线程的，但ES6推出了Web Worker来实现多线程：

Web Worker是浏览器提供的一个执行JS的独立线程，它具有自己的事件循环和全局对象，但不能直接操作DOM，需要通过post Message与主线程进行通信。



### 如何实现浏览器标签页间的通信

其实标签页间的通信就是利用浏览器底层的进程之间通信实现的。标签页之间是不能直接进行通信的，所以本质上都是利用一个中介进行传话，不同方法只是选择的中介不同。



1. **`postMessage`**（窗口引用直连）

与web Worker中的post Message不同，此处的`postMessage`通过`windows.postMessage`调用，是一个跨窗口的API。通过拿到目标页面的窗口引用实现互发，所以该方法只适用于两个窗口有引用或嵌套，不适用于两个独立的窗口。

**适用场景**：父子窗口、跨域 `iframe`、`window.open` 场景。

**缺点**：



2. **`webSocket`**（服务器做中介）

每个标签页与浏览器建立长连接，通过`onmessage`方法将要广播的信息发送给服务端，服务端再发送给其他标签页。

```js
const ws = new WebSocket("wss://example.com/ws")
ws.onmessage = e => {console.log('收到消息：', event.data)}
```

**缺点**：重度依赖后端服务。



3. **`SharedWorker`**（浏览器内共享线程充当中介）

`SharedWorker` 接口代表一种特殊的 `worker`，可以在多个<u>浏览器上下文</u>之间共享，前提是这些上下文都是<u>同源</u>的。

[^浏览器上下文]: 一块独立的环境，用来执行JavaScript、渲染页面并处理各种Web API。一个上下文就是浏览器运行网页所需要的一切环境和状态的总和。
[^同源]: 同源概念来自于同源策略，如果两个URL的协议、域名、端口号（默认是443）都相同则说明它们是同源的。（完整的URL由协议、域名、端口号、路径、查询参数构成）

​       **具体实现：**

- 当多个标签页实例化同一个`SharedWorker`时它们会连接到同一个Worker线程。
- 标签页通过`port`对象向`SharedWorker`发送消息：`port.postMessage()`
- `SharedWorker`收到数据后会通过所有`port`对象将消息转发给其他所有已连接的标签页。

**缺点**：必须同源



4. **`localStorage`/`sessionStorage`**

Storage事件常用于持久化存储，但也可以结合`window.onstorage`来实现标签页间通信。
